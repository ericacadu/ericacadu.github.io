<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Callback</title>
    <url>/jscore/20210411/2156861040/</url>
    <content><![CDATA[<h2 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h2><p>Callback Function 和一般函式沒有什麼不同，差別在於被呼叫執行的時機。<br>JavaScript 是一個「<strong>事件驅動</strong>」的程式語言，也就是說每段程式都必須滿足一定的驅動條件，才會啟動執行程式。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;This is a function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果沒有呼叫 fn，就不會執行函式</span></span><br></pre></td></tr></table></figure>
<p>所謂的「Callback Function」其實就是「<strong>把函式當作參數，透過另外一個函式呼叫</strong>」。<br>可以解釋成：希望在某個 <strong>地點</strong>，透過某個 <strong>動作</strong>，執行某個 <strong>程式</strong>，來達成結果。</p>
<div class="alert alert-info">
地點.addEventListener('動作', 參數)
</div>

<p>我們可以用一段匿名函式的方式把函式帶入參數：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;This is callback function.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以用具名函式的方式帶入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">active</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;This is callback function.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, active)</span><br></pre></td></tr></table></figure>
<h2 id="控制多個函式間執行的順序"><a href="#控制多個函式間執行的順序" class="headerlink" title="控制多個函式間執行的順序"></a>控制多個函式間執行的順序</h2><p>Callback Function 還有另外一個功能，就是「<strong>控制多個函式間執行的順序</strong>」。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br></pre></td></tr></table></figure>

<p>範例中定義兩個函式，並且分別啟動 <code>funcA</code> 和 <code>funcB</code>，此時兩個函式都會被立刻執行。<br>如果這時用非同步程式加上一段等待時間：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br></pre></td></tr></table></figure>
<p>這樣就沒辦法確定 <code>funcA</code> 和 <code>funcB</code> 誰會先出現。<br>類似這種情況，為了確保執行順序，就會透過 Callback 的方式來處理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        callback()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 將 funcB 作為參數帶入 funcA</span></span><br><span class="line">funcA(funcB)</span><br></pre></td></tr></table></figure>
<p>如此一來就能確保，無論 <code>funcA</code> 的等待時間有多長，<code>funcB</code> 都會在 <code>funcA</code> 結束後才接著執行。<br>但是如果程式之間相依程度過深，就會造成傳說中的 <strong>波動拳</strong>，也就是「<strong>Callback Hell</strong>」，讓程式難以維護。<br><img src="https://i.imgur.com/L5NnPh5.png"></p>
<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10192739">重新認識 JavaScript: Day 18 Callback Function 與 IIFE</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop</title>
    <url>/jscore/20210416/712608437/</url>
    <content><![CDATA[<h2 id="執行堆疊-Call-Stack"><a href="#執行堆疊-Call-Stack" class="headerlink" title="執行堆疊 Call Stack"></a>執行堆疊 Call Stack</h2><p>JavaScript 是一種單執行緒的程式語言，也就是一次只能做一件事情，程式碼也是一行一行執行。<br>當呼叫函式時會產生執行環境，如果函式執行環境內還有其他函式被呼叫，就會產生另外一個執行環境，形成「<strong>執行堆疊</strong>」(Call Stack)，在上層執行環境結束之前，下層包含全域的執行環境內的程式碼就會被暫停。</p>
<span id="more"></span>

<p>而堆疊的函式會以「後進先出」順序執行，當最上層的函式最後被堆疊上去，就會被最先執行，執行完後就會被移出堆疊環境，接著才繼續執行下一層函式。<br><img src="https://i.imgur.com/SORNjlE.png?70" alt="Image"></p>
<p>因此如果堆疊太多執行環境，或某個堆疊執行過久，就有可能影響整個執行環境的運行，這種狀況稱為「<strong>阻塞</strong>」(Blocking)。<br>以下方範例來說，如果在函式內不斷呼叫自己，就會呈現一個無止盡的 callback hell 波動拳，<code>foo(foo(foo(...))))</code>，這個時候瀏覽器為了避免阻塞太久，就會先暫停執行並且跳出錯誤提示 <code>Uncaught RangeError: Maximum call stack size exceeded</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h2 id="事件佇列-Event-Queue"><a href="#事件佇列-Event-Queue" class="headerlink" title="事件佇列 Event Queue"></a>事件佇列 Event Queue</h2><p>JavaScript 一次只能執行一件事情，我們可以同時執行很多件事情，是因為瀏覽器不只提供執行環境，還提供很多「<strong>WebAPI</strong>」可以使用。<br>為了避免阻塞發生，瀏覽器會先把非同步事件透過 WebAPI 先放到「<strong>事件佇列</strong>」中，等到堆疊的程式碼都執行結束後，才會把事件佇列裡的任務再放進 stack 裡執行。</p>
<ul>
<li>同步：一次一件事情，依序執行</li>
<li>非同步：很多件事情同時開始，不同時間結束</li>
</ul>
<p><img src="https://i.imgur.com/ECdJoKe.png?70" alt="Image"></p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>那究竟什麼是 Event Loop 呢？<br>可以把 Event Loop 想像成是運行整個執行環境流程的執行程式，他負責檢查 stack 裡的事件是否被清空，如果是空的，就會到 Event Queue 檢查任務，再放到 Stack 裡去執行。</p>
<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://medium.com/itsems-frontend/javascript-event-loop-event-queue-call-stack-74a02fed5625">Javascript 的事件循環 (Event Loop)、事件佇列 (Event Queue)、事件堆疊 (Call Stack)：排隊</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10221944">JS 原力覺醒 Day13 - Event Queue &amp; Event Loop 、Event Table</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>提升 Hoisting</title>
    <url>/jscore/20210820/4175334150/</url>
    <content><![CDATA[<p>在 <strong>創造環境</strong> 將記憶體空間準備好的流程，稱為 <strong>提升 (Hoisting)</strong> 。</p>
<span id="more"></span>

<p>先看以下三段程式碼範例：<br>在正常情況下，我們會先宣告變數，接著再使用或查看變數。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Ming = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Ming) <span class="comment">// 小明</span></span><br></pre></td></tr></table></figure>
<p>如果沒有事先宣告的話，就會出現變數尚未被定義的錯誤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Ming) <span class="comment">// Ming is not defined</span></span><br></pre></td></tr></table></figure>
<p>但是以下程式碼在查看 Ming 之後才宣告變數，卻會得到 undefined 的結果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Ming) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> Ming = <span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>
<p>這是因為 JavaScript 在執行的時候會分為 <strong>創造</strong> 和 <strong>執行</strong> 兩個階段。</p>
<div class="alert alert-success">
在創造階段時，會先把全域環境下的所有變數都先存進記憶體，如果在此時查看，便會出現 undefined 的結果，接著在執行階段時才會將變數賦值。
</div>

<p>因此第三個範例可以這樣拆解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造階段：先創造記憶體，但尚未賦值</span></span><br><span class="line"><span class="keyword">var</span> Ming</span><br><span class="line"></span><br><span class="line"><span class="comment">// 執行階段：在賦值前就先查看，所以會出現 undefined 的結果</span></span><br><span class="line"><span class="built_in">console</span>.log(Ming)</span><br><span class="line">Ming = <span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="函式的提升"><a href="#函式的提升" class="headerlink" title="函式的提升"></a>函式的提升</h2><p><strong>函式陳述式</strong> 在創造階段就會先準備好記憶體和函式，因此可以在任何地方呼叫函式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">callName() <span class="comment">// 小明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拆解函式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 執行</span></span><br><span class="line">callName()</span><br></pre></td></tr></table></figure>

<h2 id="函式優先"><a href="#函式優先" class="headerlink" title="函式優先"></a>函式優先</h2><div class="alert alert-info">
在創造階段，函式優先，然後才是變數
</div>

<h3 id="函式表達式-1"><a href="#函式表達式-1" class="headerlink" title="函式表達式 1"></a>函式表達式 1</h3><p>如果使用 <strong>函式表達式</strong>，因為 <strong>函式優先</strong> 的原則，會有不一樣的結果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">callName()</span><br><span class="line"><span class="keyword">var</span> callName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// callName is not a function</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>函式表達式</strong> (運算式)中，因為先宣告一個變數，在創造階段會先準備記憶體但還不會先賦值，若在此時執行函式，JavaScript 會判斷變數不是一個函式，直到執行階段時才會把函式指派給變數。</p>
<p>拆解函式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造</span></span><br><span class="line"><span class="keyword">var</span> callName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 執行：在執行階段，才會把函式內容指派給變數</span></span><br><span class="line">callName()</span><br><span class="line">callName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="函式表達式-2"><a href="#函式表達式-2" class="headerlink" title="函式表達式 2"></a>函式表達式 2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">callName()</span><br><span class="line"><span class="comment">// 小明1</span></span><br></pre></td></tr></table></figure>

<p>拆解函式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造階段：函式優先於變數</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> callName</span><br><span class="line"></span><br><span class="line"><span class="comment">// 執行</span></span><br><span class="line">callName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;小明1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">callName()</span><br></pre></td></tr></table></figure>

<br>

<h2 id="為什麼需要-Hoisting"><a href="#為什麼需要-Hoisting" class="headerlink" title="為什麼需要 Hoisting?"></a>為什麼需要 Hoisting?</h2><p>Hoisting 最初的設計是為了實現函式互相傳遞，畢竟在開發時會不只有一個函式，如果每個函式都要事先宣告的話，不僅繁瑣而且不好使用，如果有 Hoisting 的話就可以在任何地方呼叫函示。</p>
<br>

<h2 id="undefined-與-not-defined"><a href="#undefined-與-not-defined" class="headerlink" title="undefined 與 not defined"></a>undefined 與 not defined</h2><ul>
<li>undefined：記憶體已建立，但尚未給予值，屬於不明確狀態</li>
<li>not defined：尚未定義變數，所以記憶體尚未建立</li>
</ul>
<div class="alert alert-danger">
宣告變數時應避免定義 undefined，若需使用不確定變數，則可使用 null
</div>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://www.hexschool.com/courses/js-core.html">JavaScript 核心篇</a></li>
<li><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">我知道你懂 hoisting，可是你了解到多深？</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 方法</title>
    <url>/jscore/20210411/1110903207/</url>
    <content><![CDATA[<p><code>Promise</code> 是用來解決 AJAX 非同步問題，優化非同步程式的 ES6 語法，會回傳「<strong>接受</strong>」或「<strong>拒絕</strong>」的結果。</p>
<div class="alert alert-info">
    AJAX 是 JavaScript 與 XML 技術的縮寫，網頁不用重新整理，就能即時透過瀏覽器跟伺服器溝通、撈取資料。
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function promise(num) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    num ? resolve(num) : reject(&#39;失敗&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<hr>
<p>以下整理一些 Promise 方法：</p>
<h2 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve 和 Promise.reject"></a>Promise.resolve 和 Promise.reject</h2><p><code>Promise.resolve</code> 和 <code>Promise.reject</code> 都是直接定義 <code>Promise</code> 物件已完成的狀態，會產生一個新的 <code>Promise</code> 物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;success&#x27;</span>) <span class="comment">// 成功部分可以正確接收結果</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;fail&#x27;</span>) <span class="comment">// 失敗部分不會取得結果</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;fail&#x27;</span>) <span class="comment">// 只會取得失敗結果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p><code>Promise.race</code> 會透過陣列執行多個 <code>Promise</code>，但僅會回傳第一個結果，無論結果為成功或失敗。</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p><code>Promise.all</code> 會透過陣列傳入多個 <code>Promise</code> 函式，在「<strong>全部執行完後</strong>」回傳陣列局果，並且順序與一開始傳入一致，適合「<strong>多支API一起執行</strong>」，確保全部完成後才進行其他工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([promise(<span class="number">1</span>), promise(<span class="number">2</span>), promise(<span class="number">3</span>)])</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p><code>Fetch</code> 會使用 ES6 的 Promise 作回應（then、catch），回傳的資料為 <code>ReadableStream</code> 物件，需要使用不同資料類型的應對方法，才能正確取得資料。</p>
<p><code>ReadableStream</code> 的資料類型有：<code>text()</code>、<code>json()</code>、<code>formData()</code>、<code>blob()</code>、<code>arrayBuffer()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json&#x27;</span></span><br><span class="line"></span><br><span class="line">fetch(url)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.json() <span class="comment">// 先轉成 json 格式</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// 再接收轉換後的資料</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/">JavaScript Promise 全介紹</a></li>
<li><a href="https://medium.com/@brianwu291/learn-basic-javascript-es6-part2-d8fe175107c3">淺談JavaScript ES6入門Part2-類別、物件與建構式</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-es6-promise/content/">從Promise開始的JavaScript異步生活</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10194388">ES6 Fetch 遠端資料方法</a></li>
<li><a href="https://www.oxxostudio.tw/articles/201908/js-fetch.html">JavaScript Fetch API 使用教學</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>This</title>
    <url>/jscore/20210412/1591487769/</url>
    <content><![CDATA[<h2 id="this-是什麼"><a href="#this-是什麼" class="headerlink" title="this 是什麼"></a>this 是什麼</h2><p>this 是 JavaScript 的一個關鍵字，函式執行時自動生成的一個內部物件，用來呼叫自身擁有的屬性或值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><img src="https://i.imgur.com/kIAxMWk.png" alt="Image"></p>
<hr>
<h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p><code>this</code> 的值跟「作用域」或「程式碼位置」在哪裡 <font color="red">完全無關</font>，只跟「<font color="red"><strong>如何呼叫</strong></font>」有關。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 全域</span></span><br></pre></td></tr></table></figure>
<h2 id="影響函式-this-的調用方式"><a href="#影響函式-this-的調用方式" class="headerlink" title="影響函式 this 的調用方式"></a>影響函式 this 的調用方式</h2><ul>
<li>作為物件方法</li>
<li>簡易呼叫 simple call (不建議使用 this)</li>
<li>bind、apply、call 方法</li>
<li>new</li>
<li>DOM 事件處理器（用 <code>console.dir()</code> 取代 <code>console.log()</code>）</li>
<li>箭頭函式</li>
</ul>
<h2 id="物件方法"><a href="#物件方法" class="headerlink" title="物件方法"></a>物件方法</h2><p>不管函式如何被定義，只管如何被執行，以下範例為例：<br>執行 <code>obj.func()</code>，因為在物件底下被呼叫，所以 <code>this</code> 指向物件。<br>如果另外宣告 <code>var newFunc = obj.func</code>，再執行 <code>newFunc()</code>，因為在全域底下被執行，所以 <code>this</code> 指向全域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    scope: <span class="string">&#x27;物件&#x27;</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func() <span class="comment">// 物件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFunc = obj.func</span><br><span class="line">newFunc() <span class="comment">// 全域</span></span><br></pre></td></tr></table></figure>

<h2 id="簡易呼叫-Simple-Call"><a href="#簡易呼叫-Simple-Call" class="headerlink" title="簡易呼叫 Simple Call"></a>簡易呼叫 Simple Call</h2><p>用 simple call 的方式調用時，如果沒有另外定義 <code>this</code>，此時 <code>this</code> 指的就是全域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    scope: <span class="string">&#x27;物件&#x27;</span>,</span><br><span class="line">    func () &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">        &#125;</span><br><span class="line">        func2() <span class="comment">// simple call // 全域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func() <span class="comment">// 全域</span></span><br></pre></td></tr></table></figure>
<p>雖然 simple call 的 <code>this</code> 是指向全域，但並不是在 <code>window</code> 的物件下去執行函式。<br>所以如果使用立即函式的話，<code>window.func()</code> 就會出現錯誤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.func()</span><br><span class="line">    <span class="comment">// window.func is not a function</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>另外 simple call 還有其他形式，像是閉包、callback function 等都是屬於 simple call。</p>
<h3 id="閉包-Closure"><a href="#閉包-Closure" class="headerlink" title="閉包 Closure"></a>閉包 Closure</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closureFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFunc = closureFunc()</span><br><span class="line">newFunc() <span class="comment">// window</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>將一個函式以參數的方式帶入另一個函式，並在另一個函式內執行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback()</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">&#125;) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code> 也是 callback function 的一種，所以也是屬於 simple call。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// window window window</span></span><br></pre></td></tr></table></figure>

<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>setTimeout</code> 也是 callback function 的一種，所以也是屬於 simple call。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    scope: <span class="string">&#x27;local&#x27;</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<h2 id="強制綁定-this"><a href="#強制綁定-this" class="headerlink" title="強制綁定 this"></a>強制綁定 this</h2><p>雖然 this 有自己的預設值，但仍然可以用一些方法改變 this 的值。<br>綁定方式有三種：<code>call()</code>、<code>apply()</code>、<code>bind()</code><br><code>call()</code> 和 <code>apply()</code> 很類似，差別在於 <code>call()</code> 是「依序」傳入參數， <code>apply()</code> 是傳入陣列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1, 2</span></span><br><span class="line">func.call(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// undefined, 1, 2</span></span><br><span class="line">func.apply(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// undefined, 1, 2</span></span><br></pre></td></tr></table></figure>
<p>由以上範例可以得知 <code>call()</code> 和 <code>apply()</code> 的第一個參數指的就是 this 的值。<br>所以如果把 <code>undefined</code> 改成其他內容，this 的值就會被替換掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line">func.call(<span class="string">&#x27;call&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// call, 1, 2</span></span><br><span class="line">func.apply(<span class="string">&#x27;apply&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// apply, 1, 2</span></span><br></pre></td></tr></table></figure>

<p><code>call()</code> 和 <code>apply()</code> 都可以立刻執行，但是 <code>bind()</code> 不會，並須在調用時才會「依序」執行。<br>而且一旦 <code>bind()</code> 之後，this 的值就不會再改變。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> func2 = func.bind(<span class="string">&#x27;bind&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">func2() <span class="comment">// bind, 1, 2</span></span><br><span class="line">func2.call(<span class="string">&#x27;call&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// bind, 1, 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在非嚴格模式下，如果參數為 <code>null</code>、<code>undefined</code>，this 會自動轉成全域物件，this 會被指向 window，並且帶入的值會以建構式的方式呈現。<br>但是如果在嚴格模式下，就會保持原本的參數類型，this 的本質其實是 undefined，所以盡量不要用 simple call 的方式調用 this。</p>
</blockquote>
<h2 id="箭頭函式"><a href="#箭頭函式" class="headerlink" title="箭頭函式"></a>箭頭函式</h2><p>箭頭函式沒有自己的 <code>this</code>，<code>this</code> 會指向外層的作用域。<br>以傳統函式的 <code>setTimeout</code> 為例，當執行 <code>setTimeout</code> 時，因為是 <code>callback</code>函式的關係，所以 <code>this</code> 會指向全域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    scope: <span class="string">&#x27;物件&#x27;</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func() <span class="comment">// 全域</span></span><br></pre></td></tr></table></figure>
<p>如果改成箭頭函式的話，<code>this</code> 會被限制在作用域內，所以會指向物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    scope: <span class="string">&#x27;物件&#x27;</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.scope)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.func() <span class="comment">// 物件</span></span><br></pre></td></tr></table></figure>
<p><strong>＊陷阱</strong><br>箭頭函式的 <code>this</code> 要看外層是否有函式，如果沒有，則 <code>this</code> 指向全域。<br>以下範例 <code>callName()</code> 外層沒有函式，所以會指向全域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域&#x27;</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  callName: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">person.callName() <span class="comment">// 全域</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://kuro.tw/posts/2017/10/17/What-s-THIS-in-JavaScript-%E4%B8%AD/">What’s THIS in JavaScript ?</a></li>
<li><a href="https://blog.techbridge.cc/2019/02/23/javascript-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>九九乘法表 - JS 地下城</title>
    <url>/js-underground/20210420/2028242470/</url>
    <content><![CDATA[<h2 id="切版需求"><a href="#切版需求" class="headerlink" title="切版需求"></a>切版需求</h2><ul>
<li>需使用 JS for 迴圈技巧，裡頭數字不能直接寫在 HTML 上，需使用 JS 印出。</li>
<li>需使用 HTML、CSS、JS 技術</li>
<li>介面需與設計稿一致：<a href="https://xd.adobe.com/spec/256981fc-ef65-4d9b-773c-45d8ef0353c6-5358/screen/50fba855-bde7-4771-b73c-3fd839418cf0/specs/">UI 線上設計稿</a></li>
</ul>
<span id="more"></span>

<hr>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 的部分使用 Pug 撰寫，這邊就不再多贅述，從 Sass 樣式開始說明。</p>
<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>在切版之前，首先要定義好會用到的共用變數，例如顏色、字體等等，加快撰寫速度。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$primary: #2EB738</span><br><span class="line">$second: #D8D8D8</span><br><span class="line">$light: #FFFFFF</span><br><span class="line">$bgColor: #F0F0F0</span><br><span class="line"></span><br><span class="line">$fs-xl: 5em</span><br><span class="line">$fs-l: 2em</span><br><span class="line">$fs-m: 24px</span><br><span class="line">$fs-s: 0.8em</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/0x9i804.png?300x" alt="Image"></p>
<p>觀察設計稿，在左上方第一格的四個角，分別都用 <code>x</code> 作為裝飾。<br>為了減少 HTML 結構的複雜度，通常裝飾性質的元素會盡量避免直接寫在 HTML 上，類似這種裝飾可以用偽元素 <code>::before</code>、<code>::after</code> 和 <code>text-shadow</code> 搭配使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid $primary</span><br><span class="line">  border-bottom: <span class="number">1px</span> solid $primary</span><br><span class="line">  position: relative</span><br><span class="line">  &amp;::before, &amp;::after</span><br><span class="line">    content: <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    display: block</span><br><span class="line">    font-size: $fs-s</span><br><span class="line">    font-weight: <span class="number">300</span></span><br><span class="line">    position: absolute</span><br><span class="line">    left: -<span class="number">11%</span></span><br><span class="line">    text-shadow: <span class="number">14em</span> <span class="number">0</span> <span class="number">0</span> $primary</span><br><span class="line">    transform: <span class="built_in">translateY</span>(-<span class="number">0.7em</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>, <span class="number">0.9</span>)</span><br><span class="line">  &amp;::before</span><br><span class="line">    top: <span class="number">0</span></span><br><span class="line">  &amp;::after</span><br><span class="line">    top: <span class="number">100%</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>在切版需求裡有提到，這邊需要使用 JS 迴圈的方式，將內容渲染在網頁上。<br>所以可以先思考一下，會用到哪些迴圈：</p>
<ul>
<li>大的索引數字</li>
<li>內容列表</li>
</ul>
<p>首先要將大的索引數字渲染出來：<br>先建立一個 <code>&lt;ul&gt;</code> 元素當作容器，並透過 <code>appendChild()</code> 加進 DOM 節點。<br>接著建立索引元素 <code>&lt;li&gt;</code>，把數字 <code>i</code> 放進去後一併加進剛才建立的 <code>&lt;ul&gt;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.container .wrapper&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">let</span> table = <span class="built_in">document</span>.createElement(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">	table.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">	container.appendChild(table)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">	index.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">	index.textContent = i</span><br><span class="line">	table.appendChild(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/g0Ukoxp.png?70" alt="Image"></p>
<p>接著在迴圈裡面加入第二層迴圈，這次的迴圈是計算內容，所以初始值是從 1 開始。<br>建立要存放內容的 <code>&lt;li&gt;</code> 後，把要顯示的變數放進去，最後再加進容器 <code>&lt;ul&gt;</code> 就完成了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.container .wrapper&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> k=<span class="number">1</span>; k&lt;=<span class="number">9</span>; k++) &#123;</span><br><span class="line">		<span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">		item.textContent = <span class="string">`<span class="subst">$&#123;i&#125;</span> x <span class="subst">$&#123;k&#125;</span> = <span class="subst">$&#123;i*k&#125;</span>`</span></span><br><span class="line">		table.appendChild(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/vJFcelW.png?70" alt="Image"></p>
<hr>
<h2 id="完成作品"><a href="#完成作品" class="headerlink" title="完成作品"></a>完成作品</h2><p><a href="https://codepen.io/ericadu/pen/yLgRNbM">Coedpen</a></p>
]]></content>
      <categories>
        <category>JS 地下城</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件傳遞機制</title>
    <url>/note/20210419/2117635506/</url>
    <content><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 全名為 Document Object Model 中文翻譯為 文件物件模型。<br>其實就是把 HTML 文件內的標籤、文字、圖片等等都定義成物件，而這些物件會形成一個樹狀結構，並且可以利用 JavaScript 來對 HTML 文件進操作和互動。<br><img src="https://i.imgur.com/3R0iZSd.png?70" alt="Image"></p>
<span id="more"></span>
<hr>
<h2 id="DOM-節點-node"><a href="#DOM-節點-node" class="headerlink" title="DOM 節點 (node)"></a>DOM 節點 (node)</h2><p>在 DOM 中，節點可以分成四種：<br><strong>Document</strong><br>HTML 檔的開端，所有的一切都會從 Document 開始往下進行<br><strong>Element</strong><br>文件內的各個標籤，像是 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等等各種 HTML Tag 都是被歸類在 Element 裡面<br><strong>Text</strong><br>各個標籤內的文字內容<br><strong>Attribute</strong><br>各個標籤內的相關屬性，像是 class、href 等等</p>
<h2 id="捕獲與冒泡"><a href="#捕獲與冒泡" class="headerlink" title="捕獲與冒泡"></a>捕獲與冒泡</h2><p>JavaScript 是事件驅動的程式語言，也就是說，當 user 對網頁做了指定動作，才會觸發程式執行動作。<br>前面提到 DOM 會以物件形式定義 HTML 內的元件，這些物件會連結形成一個樹狀節構，而為了操控這些物件節點，需要透過 DOM 裡面的事件傳遞機制。<br>當我們要獲得一個 DOM 的 click 事件時，會這樣寫：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>裡面的 <code>e</code> 包含許多關於這次事件的相關參數，其中一個參數 <code>eventPhase</code> 表示這個事件在哪一個階段（Phase）觸發。<br>事件傳遞機制總共分為三大階段：</p>
<ul>
<li><p><strong>捕獲階段 (Capture Phase)</strong><br>在捕獲階段，DOM 的事件會從根節點 (window) 開始往下尋找目標 (target)，這個過程稱為捕獲階段 (CAPTURING_PHASE)。</p>
</li>
<li><p><strong>目標階段 (Target Phase)</strong><br>在找到目標的時候，就會是目標階段 (AT_TARGET)。</p>
</li>
<li><p><strong>冒泡階段 (Bubbling Phase)</strong><br>從子節點一路回傳到根節點，這個階段就稱作冒泡階段 (BUBBLING_PHASE)。</p>
</li>
</ul>
<blockquote>
<p>// PhaseType<br>const unsigned short      CAPTURING_PHASE                = 1;<br>const unsigned short      AT_TARGET                      = 2;<br>const unsigned short      BUBBLING_PHASE                 = 3;</p>
</blockquote>
<p><img src="https://i.imgur.com/q2XcwDc.png?60" alt="Image"></p>
<p>用以下範例說明，在一般情況下，當點擊了 <code>a</code> 連結，因為傳遞機制的關係，其實會連同外層的<code>&lt;li&gt;</code>、<code>&lt;ul&gt;</code> 也一起被觸發。<br>從最外層的 <code>&lt;ul&gt;</code> 開始往下捕獲，然後找到目標 <code>&lt;a&gt;</code>，接著再冒泡回到 <code>&lt;ul&gt;</code>。</p>
<iframe height="500" style="width: 100%;" scrolling="no" title="捕獲與冒泡" src="https://codepen.io/ericadu/embed/oNBPpop?height=463&theme-id=dark&default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/ericadu/pen/oNBPpop'>捕獲與冒泡</a> by Erica
  (<a href='https://codepen.io/ericadu'>@ericadu</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>


<h2 id="停止事件傳遞-stopPropagation"><a href="#停止事件傳遞-stopPropagation" class="headerlink" title="停止事件傳遞 stopPropagation"></a>停止事件傳遞 stopPropagation</h2><p>在開發程式的過程中，可以加上 <code>e.stopPropagation()</code> 來停止冒泡事件。</p>
<iframe height="500" style="width: 100%;" scrolling="no" title="捕獲與冒泡 stopPropagation" src="https://codepen.io/ericadu/embed/RwKYywj?height=499&theme-id=dark&default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/ericadu/pen/RwKYywj'>捕獲與冒泡 stopPropagation</a> by Erica
  (<a href='https://codepen.io/ericadu'>@ericadu</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>用以上範例說明，我在 <code>&lt;a&gt;</code> 連結裡加入 <code>e.stopPropagation()</code>，點擊按鈕後會沒有反應，再對 <code>&lt;li&gt;</code> 點擊時會顯示前一個動作回傳的內容。<br>從回傳結果可以發現，當點擊 <code>&lt;a&gt;</code> 連結時，因為停止冒泡的關係，所以事件傳遞只到找到目標就停止，並沒有繼續回傳事件。而第二次點擊的 <code>&lt;li&gt;</code> 沒有加上 <code>e.stopPropagation()</code>，所以會繼續冒泡，完成整個傳遞過程。<br><img src="https://i.imgur.com/swBsYBT.png?40" alt="Image"></p>
<h2 id="取消預設行為-preventDefault"><a href="#取消預設行為-preventDefault" class="headerlink" title="取消預設行為 preventDefault"></a>取消預設行為 preventDefault</h2><p><code>stopPropagation()</code> 常和 <code>preventDefault()</code> 搞混，但其實兩者沒什麼關係。<br><code>preventDefault()</code> 也是 <code>e</code> 的點擊事件參數之一，功能是取消瀏覽器的預設行為。<br>舉例來說，如果想要點擊 <code>&lt;a&gt;</code> 連結又不想讓預設的超連結轉跳到別的網頁，就可以加上 <code>e.preventDefault()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">link.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10202689">Day03-深入理解網頁架構：DOM</a></li>
<li><a href="https://medium.com/itsems-frontend/javascript-event-bubbling-capturing-794cd2d01e61">Javascript 中的 DOM 事件傳遞機制：捕獲與冒泡 (capturing and bubbling)</a> </li>
</ul>
]]></content>
      <categories>
        <category>筆記</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const</title>
    <url>/jscore/20210411/659913096/</url>
    <content><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>var</code> 的宣告屬於 <strong>全域變數</strong>，代表 <strong>全域物件的屬性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>假設一個 <code>for</code> 迴圈用 <code>var</code> 宣告 <code>i</code>，在全域還是可以取得 <code>i</code> 值。<br>如果想要限制 <code>i</code> 的作用域的話，可以使用立即函式，避免外層取到 <code>for</code> 迴圈裡面的值，最直接的方式就是使用 <code>let</code> 宣告。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// i is not defined</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// i is not defined</span></span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，<code>var</code> 的作用域是函式作用域，但在函式內的區域變數也可能被視為全域變數，傳統用 <code>var</code> 宣告變數可能會汙染全域，如果使用 <code>let</code>、<code>const</code> 就可以避免這種情形。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code> 的作用域屬於區塊內({} 大括號)，和 <code>const</code> 最大差異就是可以重新賦值，而 <code>const</code> 不行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// 因為 let 的作用域是區塊內，所以不算重複宣告</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>舉個非同步 <code>for</code> 迴圈的例子，假設想要讓 <code>setTimeout</code> 依序執行並印出結果，如果用 <code>var</code> 宣告的話，因為 <code>var</code> 是全域變數，所以只會取出最後一次執行的結果。<br>而 <code>setTimeout</code> 是非同步程式，會先放到「事件佇列」裡面，等到所有程式碼執行完畢後才會執行。<br>如果想要達到預期結果，只要用 <code>let</code> 宣告就可以依序執行並取得正確數值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`這是第 <span class="subst">$&#123;i&#125;</span> 次執行結果`</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125; <span class="comment">// 這是第 3 次執行結果</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`這是第 <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span> 次執行結果`</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 這是第 0 次執行結果</span></span><br><span class="line"><span class="comment">// 這是第 1 次執行結果</span></span><br><span class="line"><span class="comment">// 這是第 2 次執行結果</span></span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code> 是宣告一個常數，用 <code>const</code> 宣告的變數沒辦法再被調整。<br>雖然變數沒辦法被調整，但如果是物件的話，因為物件屬於傳參考特性，只要不直接替換掉物件，可以修改內容屬性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    money: <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line">person.name = <span class="string">&#x27;大明&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 大明</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line">person = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="Hoisting-與-暫時性死區"><a href="#Hoisting-與-暫時性死區" class="headerlink" title="Hoisting 與 暫時性死區"></a>Hoisting 與 暫時性死區</h2><p>JavaScript 中有 hoisting 的現象，先來比較一下這三種的狀況：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>var: <code>undefined</code>，有 hoisting</li>
<li>let: <code>not defined</code>，沒有 hoisting</li>
<li>const: 宣告前無法使用，沒有 hoisting</li>
</ol>
<p>看起來沒什麼問題，接著猜測一下面範例結果：</p>
<ul>
<li>(1) 如果 <code>let</code> 沒有提升的話，就會往外層查找取得 <strong>小明</strong> 的值</li>
<li>(2) 如果 <code>let</code> 有提升的話，就會出現其他狀況</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Ming = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Ming)</span><br><span class="line">    <span class="keyword">let</span> Ming = <span class="string">&#x27;大明&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>結果是(2)： <code>Cannot access &#39;Ming&#39; before initialization</code><br><code>let</code> 在提升的過程中會產生一個「暫時性死區」Temporal Dead Zone(TDZ)。<br>在這個區域內是無法存取變數，也就不會賦予 <code>undefined</code> 的值，如果試圖取值就會跳出錯誤提示。<br>所以 <code>let</code> 雖然有類似提升 <strong>創造 - 執行階段</strong> 的概念，但是和 <code>var</code> 的 hoisting 概念並不相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Ming = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 創造</span></span><br><span class="line">    <span class="keyword">let</span> Ming <span class="comment">// 暫時性死區 TDZ</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 執行</span></span><br><span class="line">    <span class="built_in">console</span>.log(Ming)</span><br><span class="line">    <span class="keyword">let</span> Ming = <span class="string">&#x27;大明&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重點整理"><a href="#重點整理" class="headerlink" title="重點整理"></a>重點整理</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">作用範圍</th>
<th align="center">重複宣告</th>
<th align="center">重新賦值</th>
<th align="center">Hoisting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">var</td>
<td align="center">全域</td>
<td align="center">v</td>
<td align="center">v</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">let</td>
<td align="center">區塊</td>
<td align="center">x</td>
<td align="center">v</td>
<td align="center">v</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">區塊</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函式與作用域</title>
    <url>/jscore/20210411/1442787642/</url>
    <content><![CDATA[<p>函式屬於物件的一種，分為「<strong>具名函式</strong>」和「<strong>匿名函式</strong>」，包含程式碼片段，可帶入參數，並可被呼叫。</p>
<span id="more"></span>
<hr>
<h2 id="具名函式-Named-Function"><a href="#具名函式-Named-Function" class="headerlink" title="具名函式 Named Function"></a>具名函式 Named Function</h2><p>具名函式顧名思義必須要有函式名稱。<br>而具名函式能夠在函式內被調用，但是函式中的具名函式無法在函式以外被調用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sayHello() <span class="comment">// 具名函式能夠在函式內被調用</span></span><br><span class="line">&#125;</span><br><span class="line">callSayHello() <span class="comment">// Hello!</span></span><br><span class="line">inner() <span class="comment">// inner is not defined 無法被調用</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函式-Anonymous-Function"><a href="#匿名函式-Anonymous-Function" class="headerlink" title="匿名函式 Anonymous Function"></a>匿名函式 Anonymous Function</h2><p>函式名稱是可以被忽略的，也就是匿名函式，通常會用表達式來宣告匿名函式，另外立即函式（IIFE）也是屬於匿名函式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hey!&#x27;</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">sayHello()</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hey!</span></span><br></pre></td></tr></table></figure>

<h2 id="陳述式與表達式"><a href="#陳述式與表達式" class="headerlink" title="陳述式與表達式"></a>陳述式與表達式</h2><ul>
<li>陳述式：Statement</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函式陳述式、具名函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表達式：Expression（運算式、表示式）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函式表達式、匿名函式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="函式作用域-Function-Scope"><a href="#函式作用域-Function-Scope" class="headerlink" title="函式作用域 Function Scope"></a>函式作用域 Function Scope</h2><p>函式有屬於自己的作用域，在 ES6 之前，「<strong>JavaScript 切分變數有效範圍的最小單位是 function</strong>」，所以在這個範圍內的變數只屬於這個函式，一旦離開函式範圍，記憶體就會被釋放掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">6</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a = 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果在函式裡面沒有重新宣告變數，那 function 就會向外一層一層找。<br>function 可以從內層讀取外層宣告的變數，但是外層沒辦法讀取內層宣告的變數，這種行為稱作「<strong>範圍鏈（Scope Chain）</strong>」。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;local&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> innerFunc = outer()</span><br><span class="line"><span class="keyword">var</span> result = innerFunc()</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// local</span></span><br></pre></td></tr></table></figure>
<p>範例中加了一段 <code>var innerFunc = outer()</code> ，呼叫 <code>outer</code> 回傳的 <code>inner</code> 結果，取得原本從外層無法讀取的 <code>inner</code>，看似好像把 <code>inner</code> 獨立出來，msg 向外查找所以結果是的外層 <code>global</code> 。<br>但有個重要觀念：<strong>範圍鏈是在函式被定義當下決定的，不是被呼叫的時候。</strong><br>所以在「<strong>定義函式之後，呼叫函式之前</strong>」範圍鏈就已經被建立，<code>msg</code> 為 <code>inner</code> 外層的 <code>local</code>。</p>
<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10191549">重新認識 JavaScript: Day 10 函式 Functions 的基本概念</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函式與型別</title>
    <url>/jscore/20210820/3630969749/</url>
    <content><![CDATA[<h2 id="陳述式與表達式"><a href="#陳述式與表達式" class="headerlink" title="陳述式與表達式"></a>陳述式與表達式</h2><p><strong>陳述式</strong>：用於執行指令的操作，最大的特徵是 <strong>不會回傳結果</strong></p>
<blockquote>
<p>陳述式舉例：<br>(1) block { … }<br>(2) if…else<br>(3) switch<br>(4) var let const<br>(5) for 迴圈等等</p>
</blockquote>
<p><strong>表達式</strong>：又稱為運算式，是任何一段可以透過 <strong>運算子</strong> 取得一個值 (<strong>會回傳結果</strong>) 的程式碼</p>
<blockquote>
<p>運算式舉例：<br>(1) x = 1，使用「=」運算子將 1 的結果賦予給 x 的變數<br>(2) 3 + 4，「+」是運算子，雖然沒有指定變數，但是會回傳結果 7</p>
</blockquote>
<span id="more"></span>

<h3 id="函式陳述式"><a href="#函式陳述式" class="headerlink" title="函式陳述式"></a>函式陳述式</h3><p>函式陳述式又稱為 <strong>具名函式</strong>，直接給予函式名稱而不是另外定義變數。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函式表達式"><a href="#函式表達式" class="headerlink" title="函式表達式"></a>函式表達式</h3><p>函式表達式又稱為 <strong>匿名函式</strong>，先定義變數後，接著透過等號運算子將函式賦予給變數。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="原始型別與物件型別"><a href="#原始型別與物件型別" class="headerlink" title="原始型別與物件型別"></a>原始型別與物件型別</h2><p><strong>物件型別</strong>：</p>
<table>
<thead>
<tr>
<th align="center">Object</th>
<th align="center">Array</th>
<th align="center">function</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物件</td>
<td align="center">陣列</td>
<td align="center">函式</td>
</tr>
</tbody></table>
<p><strong>原始型別</strong> 分為以下幾種：</p>
<table>
<thead>
<tr>
<th align="center">Boolean</th>
<th align="center">Null</th>
<th align="center">Undefined</th>
<th align="center">Number</th>
<th align="center">String</th>
<th align="center">BigInt</th>
<th align="center">Symbol</th>
</tr>
</thead>
<tbody><tr>
<td align="center">布林</td>
<td align="center">空</td>
<td align="center">為定義</td>
<td align="center">數值</td>
<td align="center">字串</td>
<td align="center">整數數值</td>
<td align="center">Symbol</td>
</tr>
</tbody></table>
<ul>
<li>NaN 的型別為 Number</li>
<li>BigInt 是一個內建的 <strong>物件</strong>，提供了表示大於 2 的 53 次方整數的功能</li>
</ul>
<div class="alert alert-info">
null 是原始型別之一，但 typeof null 卻得到 object，而非 null
這是一個 bug，可是若修正了這個 bug 則可能會導致很多網站壞掉，因此不修正
<br>
如果要判斷 typeof null 的話要注意結果為 object
</div>


<p>如果變數是 <code>not defined</code> 尚未定義變數，那型別將會是 <strong>undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>當我們直接查看一個變數時，可以取用該變數型別可用的一些方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ming&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length)</span><br></pre></td></tr></table></figure>
<p>而這些方法是透過 <strong>包裹物件</strong> 的方式套用到變數上，可以透過 <strong>建構式</strong> 的方式來查看</p>
<div class="alert alert-danger">
在宣告原始型別時，如果使用這種方式宣告變數，則會被轉型為 <b>物件型別</b>，在使用上要特別注意
</div>

<p><img src="https://i.imgur.com/6VWZCMS.png"></p>
<br>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.hexschool.com/courses/js-core.html">JavaScript 核心篇</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>執行環境與作用域</title>
    <url>/jscore/20210819/1495754165/</url>
    <content><![CDATA[<h1 id="執行環境與作用域"><a href="#執行環境與作用域" class="headerlink" title="執行環境與作用域"></a>執行環境與作用域</h1><p>JavaScript 是屬於直譯式語言，它會直接透過直譯器來產生代碼，並且運行代碼。</p>
<span id="more"></span>

<h2 id="執行的錯誤情境"><a href="#執行的錯誤情境" class="headerlink" title="執行的錯誤情境"></a>執行的錯誤情境</h2><ul>
<li><strong>RHS (Right Hand Side)</strong> ：RHS 取值來自於右側的變數上</li>
<li><strong>LHS (Left Hand Side)</strong> ：LHS 取值來自於左側的變數上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把「小明」賦予到左側的變數上，就稱為 LHS</span><br><span class="line">var ming &#x3D; &#39;小明&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右邊的值是使用 RHS 取得變數，並且透過 LHS 賦予到左邊的變數</span><br><span class="line">var min &#x3D; ming</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="語法作用域"><a href="#語法作用域" class="headerlink" title="語法作用域"></a>語法作用域</h2><p><img src="https://i.imgur.com/O8mE7To.png"></p>
<ul>
<li><strong>靜態作用域</strong> ：語法作用域又稱為 <strong>靜態作用域</strong>，所以會在與法解析時就已經確定作用域，而且不會再改變。</li>
<li><strong>動態作用域</strong> ：變數的作用域會在函式調用時才決定。</li>
</ul>
<h3 id="範圍鍊-Scope-Chain"><a href="#範圍鍊-Scope-Chain" class="headerlink" title="範圍鍊 Scope Chain"></a>範圍鍊 Scope Chain</h3><p>JavaScript 是採用 <strong>語法作用域</strong> ，所以當函式建立時，作用域就已經被限制在函式範圍內，當在函式內宣告變數時，外層是無法讀取的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(min) <span class="comment">// 小明</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(min) <span class="comment">// min is not defined</span></span><br></pre></td></tr></table></figure>
<p>也就是說，每個函式的作用域都是獨立的，如果在函式作用域內需要特定變數，但是作用域內並沒有特定變數，此時就會向外查找；<br>如果向外查找也沒有的話，就會出現 <font color="red"><code>ReferenceError: b is not defined</code></font> 的錯誤。<br>而這個向外尋找變數的過程，就叫做 <strong>範圍鍊</strong> ，範圍練取決於函式的作用域，與執行環境沒有關係。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(b) &#125;</span><br><span class="line">fn1()</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<h3 id="容易搞混的靜態作用域-⚡⚡⚡"><a href="#容易搞混的靜態作用域-⚡⚡⚡" class="headerlink" title="容易搞混的靜態作用域 ⚡⚡⚡"></a>容易搞混的靜態作用域 ⚡⚡⚡</h3><div class="alert alert-danger">
函式建立時就已經確定作用域，並且 <b>不會改變</b> 
</div>
因此以下範例來說，當 fn1 建立時就已經確定了 value 的值為 1，就算在 fn2 重新宣告並呼叫，`value = 2` 的有效作用範圍僅止於 fn2 內，並不會影響 fn1 的內容。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line">    fn1()</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>

<h2 id="執行環境"><a href="#執行環境" class="headerlink" title="執行環境"></a>執行環境</h2><div class="alert alert-info">
建立函式後並執行 (呼叫) 函式，會產生執行環境
</div>

<p>舉例來說，如果在函式內宣告一個變數，那變數的作用域就會被限制在函式內，但是如果函式沒有被執行，就不產生執行環境，也就不會有任何變數產生。<br>也就是說，如果函式反覆被執行，就會不斷產生新的執行環境。</p>
<p>全域也有屬於自己的執行環境，建立時機在網頁一開啟，或是後端 Node.js 一開啟時，執行環境就會被建立。</p>
<h2 id="執行堆疊"><a href="#執行堆疊" class="headerlink" title="執行堆疊"></a>執行堆疊</h2><ol>
<li>當網頁一開啟時，會先建立全域執行環境</li>
<li>呼叫 doSomething 時，就會建立 doSomething 的執行環境，並且堆疊在全域執行環境之上</li>
<li>在 doSomething 內呼叫 sayHi 函式，此時 sayHi 的執行環境就會堆疊在 doSomething </li>
</ol>
<p><img src="https://i.imgur.com/vePAq5r.png"></p>
<div class="alert alert-danger">
執行環境是一層一層堆疊上去，和函式宣告的時機沒有關聯，而是和函式被呼叫的位置有關
</div>


<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.hexschool.com/courses/js-core.html">JavaScript 核心篇</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>同步 Sync 與非同步 Async</title>
    <url>/jscore/20210411/3360846865/</url>
    <content><![CDATA[<h2 id="同步與非同步的差異"><a href="#同步與非同步的差異" class="headerlink" title="同步與非同步的差異"></a>同步與非同步的差異</h2><p>在學習同步與非同步的概念時很容易混淆，「<strong>同步</strong>」光看字面上的意思，可能會誤解成「所有動作同時進行」，而其實正好相反。</p>
<span id="more"></span>
<p>就以去夜市點餐來說明，如果今天想買的東西有：雞排、QQ球、珍奶。</p>
<ul>
<li><p>同步 (sync)：先去買雞排 -&gt; 再去買QQ球 -&gt; 然後再買珍奶。<br>像這樣「先完成 A 才能做 B、C、D …」的運作方式我們就會把它稱作「<strong>同步</strong>」。</p>
</li>
<li><p>非同步 (async)：再找兩個朋友幫忙，每人去一個攤位買一樣東西，就可以同時買好雞排、QQ球、珍奶。</p>
</li>
</ul>
<p>所以同步的概念其實比較像是「<strong>一步一步來處理</strong>」的意思。<br>非同步則是，我不用等待 A 做完才做 B、C，而是這三個事情可以同時發送出去。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><strong>Promise</strong>  是 ES6 新增的建構函式，用來優化非同步的語法，增加可讀性。<br>Promise 字面上翻譯就是「約定、承諾」，可以想像成 A 和 B 約定要做某件事情，接著回報處理結果，而這個結果只能是「<strong>完成</strong>」或「<strong>拒絕</strong>」。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">        value ? resolve(<span class="string">&#x27;處理完成的結果&#x27;</span>) : reject(<span class="string">&#x27;被拒絕的原因&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="為什麼需要-Promise？"><a href="#為什麼需要-Promise？" class="headerlink" title="為什麼需要 Promise？"></a>為什麼需要 Promise？</h3><p>JavaScript 是單執行緒（同步）的程式語言，一次只能處理一件事情，所以遇到非同步的事件時，就會先把程式碼放到「<strong>事件佇列</strong>」，等到所有事件處理完後才會執行非同步事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;開始&#x27;</span>) <span class="comment">// 執行順序 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;非同步事件&#x27;</span>) <span class="comment">// 執行順序 3</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;程式碼結束&#x27;</span>) <span class="comment">// 執行順序 2</span></span><br></pre></td></tr></table></figure>

<h3 id="狀態"><a href="#狀態" class="headerlink" title="狀態"></a>狀態</h3><p>Promise 在處理非同步的事件的過程中，包含不同的進度狀態</p>
<ul>
<li>Pending：尚未得到結果</li>
<li>Resolved：事件已經執行完畢且成功操作，回傳 <code>resolve</code> 的結果</li>
<li>Rejected：事件已經執行完畢但操作失敗，回傳 <code>reject</code> 的結果<br><img src="https://i.imgur.com/I79SHF4.png" alt="Image"></li>
</ul>
<h3 id="接收回傳"><a href="#接收回傳" class="headerlink" title="接收回傳"></a>接收回傳</h3><p>Promise 可以用 <code>then</code> 和 <code>catch</code> 來接收並回傳結果：<br><code>then</code> 可以同時接收成功、失敗結果，而 <code>catch</code> 只接收失敗結果</p>
<ul>
<li><strong>使用 catch 接收失敗：</strong><br>在任何階段遇到 <code>reject</code> 時，都會直接跳到 <code>catch</code>，之後的 <code>then</code> 都不會執行<br>雖然 <code>catch</code> 依然可以使用 <code>return</code> 繼續串接，但很少這樣使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(success) <span class="comment">// resolve 接收成功 // &#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">0</span>)    <span class="comment">// return promise(0) -&gt; reject 跳到 catch</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;       <span class="comment">// 因為上面出現 reject 所以跳過</span></span><br><span class="line">        <span class="built_in">console</span>.log(success)</span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    .catch( <span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fail)    <span class="comment">// reject 接收失敗 // &#x27;失敗&#x27;</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 then 接收失敗：</strong><br><code>then</code> 中的兩個函式必定執行其中一個，可以用此方式確保所有的鏈接都能夠被執行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise(<span class="number">0</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(success)</span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fail)     <span class="comment">// reject 接收失敗 // &#x27;失敗&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">2</span>)     <span class="comment">// return promise(2)</span></span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(success) <span class="comment">// resolve 接收成功 // &#x27;2&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">0</span>)    <span class="comment">// return promise(0)</span></span><br><span class="line">    &#125;, <span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fail)</span><br><span class="line">        <span class="keyword">return</span> promise(<span class="number">4</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(success)</span><br><span class="line">    &#125;, <span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fail)     <span class="comment">// reject 接收失敗 // &#x27;失敗&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><ul>
<li>最後可以使用 <code>finally</code> 來確認工作結束</li>
<li><code>finally</code> 不帶有任何參數，適合用來確認 Ajax 已經讀取完成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(success)</span><br><span class="line">    &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10194569/">重新認識 JavaScript: Day 26 同步與非同步</a></li>
<li><a href="https://www.oxxostudio.tw/articles/201706/javascript-promise-settimeout.html">JavaScript 同步延遲 ( Promise + setTimeout )</a></li>
<li><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/">JavaScript Promise 全介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浮點數相加</title>
    <url>/note/20210414/981755103/</url>
    <content><![CDATA[<h2 id="浮點數"><a href="#浮點數" class="headerlink" title="浮點數"></a>浮點數</h2><p>在日常生活中，如果要計算 0.1 + 0.2，我們能夠直覺的答出 0.3 這個答案。<br>但是在 JavaScript 中，計算結果卻不如預期，用 <code>console.log(0.1 + 0.2 === 0.3)</code> 回傳的結果竟會得到 <code>false</code>。<br>其實這和電腦的「<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE754 二進制浮點運算</a>」計算方式有關，當我們宣告一段浮點數陣列，展開後會發現，有些浮點數會有些微誤差，以致於在進行計算時會出錯。<br>所以得到的結果自然是 <code>0.1 + 0.2 !== 0.3</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>).keys())</span><br><span class="line"><span class="keyword">var</span> result = num.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// 0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, </span></span><br><span class="line"><span class="comment">// 0.6000000000000001, 0.7000000000000001, 0.8, 0.9</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<hr>
<p>該如何解決浮點數問題呢？可以使用以下兩種方法：</p>
<ul>
<li>Number.toFixed()</li>
<li>Number.toPrecision()</li>
</ul>
<h2 id="Number-toFixed"><a href="#Number-toFixed" class="headerlink" title="Number.toFixed"></a>Number.toFixed</h2><p><code>Number.toFixed()</code> 可以對數字進行四捨五入到指定的第 N 位數。</p>
<blockquote>
<p><code>toFixed()</code> 方法回傳的型別是「<strong>字串</strong>」，需要另外再轉換為數字型別。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.12345</span></span><br><span class="line">num.toFixed(<span class="number">2</span>) <span class="comment">// &quot;10.12&quot;</span></span><br><span class="line">num.toFixed(<span class="number">4</span>) <span class="comment">// &quot;10.1235&quot;</span></span><br></pre></td></tr></table></figure>
<p>同樣方法用在浮點數上可以改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>).keys())</span><br><span class="line"><span class="keyword">var</span> result = num.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>((item * <span class="number">0.1</span>).toFixed(<span class="number">1</span>)))</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]</span></span><br></pre></td></tr></table></figure>
<p>如果想去除小數點後為 0 的尾數，則可以用 <code>parseFloat()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0.990</span></span><br><span class="line"><span class="built_in">parseFloat</span>(num) <span class="comment">// 0.99</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-toPrecision"><a href="#Number-toPrecision" class="headerlink" title="Number.toPrecision"></a>Number.toPrecision</h2><p><code>Number.toPrecision()</code> 方法可以指定想要顯示的浮點數範圍，範圍在 1～21，並且回傳「字串」。<br><code>toPrecision()</code> 方法有以下幾種狀況：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 數字是浮點數，就會補 0</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">0.12</span></span><br><span class="line">num1.toPrecision(<span class="number">5</span>) <span class="comment">// &quot;0.12000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 數字是浮點數，但位數不足，一樣會四捨五入</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">12.345</span></span><br><span class="line">num2.toPrecision(<span class="number">4</span>) <span class="comment">// &quot;12.35&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 數字是整數，但是位數不足，會轉換成指數寫法</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">1234</span></span><br><span class="line">num3.toPrecision(<span class="number">3</span>) <span class="comment">// &quot;1.23e+3&quot;</span></span><br></pre></td></tr></table></figure>
<p>所以如果想要解決浮點數相加的問題，可以改成這樣：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toPrecision(<span class="number">12</span>)) <span class="comment">// &quot;0.3&quot;</span></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.6</span> + <span class="number">0.7</span>).toPrecision(<span class="number">12</span>)) <span class="comment">// &quot;1.3&quot;</span></span><br></pre></td></tr></table></figure>
<p>至於為什麼參數要帶 12，因為 12 位數可以避免大部分浮點數的問題。</p>
<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://tso1158687.github.io/blog/2018/12/17/javascript-float-trap/">javascript浮點數的陷阱</a></li>
</ul>
]]></content>
      <categories>
        <category>筆記</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>淺層複製與深層複製</title>
    <url>/jscore/20210414/4242308893/</url>
    <content><![CDATA[<p>之前提到物件型別有傳參考的特性，但是如果想要另外修改資料，就會連帶影響原始資料內容，JavaScript 提供幾種複製方式來解決這個問題。</p>
<span id="more"></span>
<hr>
<h2 id="淺層複製-Shallow-Copy"><a href="#淺層複製-Shallow-Copy" class="headerlink" title="淺層複製 Shallow Copy"></a>淺層複製 Shallow Copy</h2><p>淺層複製只能複製物件的第一層，如果修改第二層資料的話，還是會影響原始資料。</p>
<h3 id="for-in-loop"><a href="#for-in-loop" class="headerlink" title="for-in loop"></a>for-in loop</h3><p>以下範例可以發現，用 <code>for-in</code> 迴圈複製後的新物件會和原始資料不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    title: <span class="string">&#x27;First Level&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        tag: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> data ) &#123;</span><br><span class="line">    target[key] = data[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(target !== data) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是接著修改新物件後，修改第一層的內容沒有問題，不會影響原始資料，但是修改第二層後，就會連同原始物件一起修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.title = <span class="string">&#x27;Second Level&#x27;</span> </span><br><span class="line">target.info.tag = <span class="string">&#x27;copy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target, data)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/BbbyV3N.png?55" alt="Image"></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p><code>Object.assign()</code> 可以用來複製物件本身的屬性到另外一個目標物件上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> origin = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.assign(&#123;&#125;, origin)</span><br><span class="line"><span class="built_in">console</span>.log(origin, target)</span><br><span class="line"><span class="comment">// origin = &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="comment">// target = &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果 <font color="#ff7575"><strong>目標物件</strong></font> 與 <font color="#6897bb"><strong>原始物件</strong></font> 的屬性名稱相同，<font color="#6897bb"><strong>原始物件</strong></font> 的屬性會覆蓋 <font color="#ff7575"><strong>目標物件</strong></font>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> origin = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">x</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, origin)</span><br><span class="line"><span class="built_in">console</span>.log(origin, target)</span><br><span class="line"><span class="comment">// origin = &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="comment">// target = &#123;a: 1, b: 2, x: 0, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-展開語法"><a href="#ES6-展開語法" class="headerlink" title="ES6 展開語法"></a>ES6 展開語法</h3><p>除了以上兩種方法，也可以用 ES6 的展開語法達到相同效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;...data&#125;</span><br><span class="line">target.a = <span class="number">999</span></span><br><span class="line"><span class="built_in">console</span>.log(target)</span><br><span class="line"><span class="comment">// target = &#123; a: 999, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="深層複製-Deep-Copy"><a href="#深層複製-Deep-Copy" class="headerlink" title="深層複製 Deep Copy"></a>深層複製 Deep Copy</h2><p>淺層複製只能複製第一層資料，深層複製則是可以將資料完整複製，讓整份新複製的資料都能往下層修改，並且不會影響原始資料。</p>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p><code>JSON.stringify()</code> 可以將物件轉成「字串」後回傳。<br>重新轉成字串後再用 <code>JSON.parse()</code> 轉回 JavaScript 物件，如此就能達到深層複製的效果。<br>原理是將物件先轉成「純值」，再透過 <code>JSON.parse()</code> 轉回物件，此時的物件就會有一個新的記憶體空間，並且讓變數指向到新的位置。</p>
<div class="alert alert-danger">
如果物件中有 <b>undefined、function</b>，因為無法轉成純值，所以會直接消失，<b>NaN 則會變成 Null</b>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    title: <span class="string">&#x27;First Level&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        tag: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">target.title = <span class="string">&#x27;Second Level&#x27;</span> </span><br><span class="line">target.info.tag = <span class="string">&#x27;copy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target, data)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/Zi6OaFe.png?55" alt="Image"></p>
<h3 id="jQuery-extend"><a href="#jQuery-extend" class="headerlink" title="jQuery.extend"></a>jQuery.extend</h3><p>如果要解決 <code>undefined</code>、<code>function</code> 和 <code>NaN</code> 的複製問題，可以用 jQuery 的 <code>$.extend</code> 方法，就能做到完整的深層複製。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    title: <span class="string">&#x27;First Level&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">        tag: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data.func&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    un: <span class="literal">undefined</span>,</span><br><span class="line">    nan: <span class="literal">NaN</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> shallow = $.extend(&#123;&#125;, data) <span class="comment">// 淺層複製</span></span><br><span class="line"><span class="keyword">var</span> deep = $.extend(<span class="literal">true</span>, &#123;&#125;, data) <span class="comment">// 深層複製</span></span><br><span class="line"><span class="built_in">console</span>.log(deep)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://hsiangfeng.github.io/javascript/20200905/1375484447/">JavaScript 核心觀念(30)-物件-淺層複製及深層複製</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>物件傳參考</title>
    <url>/jscore/20210413/1596758899/</url>
    <content><![CDATA[<p>JavaScript 中，資料的傳遞分為兩種方式：<br><strong>- 傳值</strong>：Call by value 或 Pass by value<br><strong>- 傳址（傳參考）</strong>：Call by reference 或 Pass by reference</p>
<span id="more"></span>

<hr>
<h2 id="傳值"><a href="#傳值" class="headerlink" title="傳值"></a>傳值</h2><p>JavaScript 中除了物件型別以外都是基本型別，基本型別就是單純的值。<br>而基本型別是透過「<strong>傳值</strong>」的方式傳遞資料：</p>
<ul>
<li>Boolean：布林</li>
<li>Null：空值</li>
<li>Undefined：未定義</li>
<li>Number：數字</li>
<li>String：字串</li>
</ul>
<p>假設今天 <code>a</code> 的值是 10，<code>b</code> 又等於 <code>a</code>，如果把 <code>a</code> 重新賦值 100，那 <code>b</code> 的結果會是什麼呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p>答案是：10。</p>
<p>在電腦裡的世界，可以想像成一個個空間，有 <strong>記憶體位置</strong> 的空間，也有 <strong>儲存值</strong> 的空間。<br>為了方便取用，才有變數的存在，再用變數連結（指向）這些記憶體位置。<br>而宣告變數賦值，就是把變數的值存進電腦裡專門存值的空間。<br>所以在傳值的概念裡，兩個變數分別儲存在不同空間，就算其中變數 <code>a</code> 重新賦值，也不會影響原本複製過去的變數 <code>b</code>。<br><img src="https://i.imgur.com/zt6x1G5.png" alt="Image"></p>
<h2 id="傳址"><a href="#傳址" class="headerlink" title="傳址"></a>傳址</h2><p>除了基本型別外，其他型別都算物件型別。<br>物件的定義需要包含 <code>key</code> 和 <code>value</code>，會以「<strong>傳址（傳參考）</strong>」的方式傳遞資料：</p>
<ul>
<li>Object：物件</li>
<li>Array：陣列</li>
<li>Function：函式</li>
</ul>
<p>以下方範例為例，變數 <code>a</code>、<code>b</code> 分別是什麼呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b.x = <span class="number">2</span></span><br><span class="line">a.y = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure>
<p>答案是：<code>a = &#123; x: 2, y: 3 &#125;</code>，<code>b = &#123; x: 2, y: 3 &#125;</code></p>
<p>因為物件是「<strong>傳址</strong>」，所以並不會重新賦值，當然也就不會準備新的儲存空間，只會指向原本的位置。當變數的值改變時，原本位置的值也會跟著改變。</p>
<p><img src="https://i.imgur.com/sjbIC8J.png" alt="Image"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// 儲存值 (1)</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// b 指向 a - 位置 (1)</span></span><br><span class="line">b.x = <span class="number">2</span> <span class="comment">// 對 a 的位置賦值</span></span><br><span class="line">a.y = <span class="number">3</span> <span class="comment">// a 的指向位置不變，對自己賦值</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br><span class="line"><span class="comment">// a = &#123; x: 2, y: 3 &#125;, b = &#123; x: 2, y: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>再以下方範例為例：<br>如果用等號再對變數 <code>b</code> 重新賦值，再宣告一個變數 <code>c</code> 指向 <code>b</code>。<br>請問變數 <code>a</code>、<code>b</code>、<code>c</code> 分別是什麼呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> c = b</span><br><span class="line">b = a</span><br><span class="line">a.y = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br></pre></td></tr></table></figure>
<p>答案是：<code>a = &#123; x: 1, y: 3 &#125;</code>，<code>b = &#123; x: 1, y: 3 &#125;</code>，<code>c = &#123; x: 2 &#125;</code><br>雖然有準備新的空間給變數 <code>b</code>，並且讓 <code>c</code> 指向 <code>b</code>，但是後來又把 <code>b</code> 指向 <code>a</code>，<code>c</code> 指向的是 <code>b</code> 原本的記憶體位置，所以當變數 <code>a</code> 的內容改變，<code>b</code> 的值也會一起改變。<br><img src="https://i.imgur.com/rAFkarQ.png" alt="Image"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125; <span class="comment">// 儲存值 (1)</span></span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125; <span class="comment">// 儲存值 (2)</span></span><br><span class="line"><span class="keyword">var</span> c = b <span class="comment">// c 指向 b - 位置 (2)</span></span><br><span class="line">b = a <span class="comment">// b 指向 a - 位置 (1)</span></span><br><span class="line">a.y = <span class="number">3</span> <span class="comment">// a 的指向位置不變，對自己賦值</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"><span class="comment">// a = &#123; x: 1, y: 3 , b = &#123; x: 1, y: 3 &#125;, c = &#123; x: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li><a href="https://medium.com/itsems-frontend/javascript-pass-by-value-reference-sharing-5d6095ae030b"> Javascript中的傳值 by value 與傳址 by reference</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>相等與隱含轉型</title>
    <url>/jscore/20210820/1249754331/</url>
    <content><![CDATA[<h2 id="相等與隱含轉型"><a href="#相等與隱含轉型" class="headerlink" title="相等與隱含轉型"></a>相等與隱含轉型</h2><h3 id="嚴格相等"><a href="#嚴格相等" class="headerlink" title="嚴格相等"></a>嚴格相等</h3><p>嚴格相等會判斷等號兩邊的 <strong>值</strong> 與 <strong>型別</strong> 皆相同<br>以下為特例，NaN 為非數值，所以不管是嚴格或是寬鬆相等都會回傳 false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>)      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>而 0 代表 false，!0 會轉為 true，因此會變成 <code>Number(1) == Number(!0)</code><br>而 <code>1 == 1</code>，所以結果會是 true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> == !<span class="number">0</span>)      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="寬鬆相等"><a href="#寬鬆相等" class="headerlink" title="寬鬆相等"></a>寬鬆相等</h3><p>布林、字串在寬鬆相等時會自動轉型為 <strong>數值</strong>，這個行為又稱為 <strong>隱含轉型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">17</span> == <span class="string">&#x27;0x11&#x27;</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 16進位制 0x1 = 16， 0x11 = 16 + 1</span></span><br></pre></td></tr></table></figure>

<p>當 true 字串轉型為數值時，會變成 NaN，因此兩者不相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="string">&#x27;true&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;true&#x27;</span>)) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="Null、undefined"><a href="#Null、undefined" class="headerlink" title="Null、undefined"></a>Null、undefined</h3><p>Null 和 undefined 在比對上不會被轉為數字型別來做比對<br>但是在寬鬆相等下，Null 和 undefined 會相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>))        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>))   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="number">0</span>)           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="物件與非物件"><a href="#物件與非物件" class="headerlink" title="物件與非物件"></a>物件與非物件</h3><p>物件與非物件的比對，會依照 <strong>左邊的型別</strong>，對右邊使用包裹物件進行轉換<br>以下範例來說，左邊是一個字串 10，因此會用 String 包裹物件將兩邊進行轉換</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span> == [<span class="number">10</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="string">&#x27;10&#x27;</span>) == <span class="built_in">String</span>([<span class="number">10</span>]))</span><br><span class="line"><span class="comment">// &#x27;10&#x27; == &#x27;10&#x27;</span></span><br></pre></td></tr></table></figure>
<p>純物件會使用 String 包裹物件進行轉換，但通常物件不會這樣進行比對</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(&#123;<span class="attr">A</span>: <span class="string">&#x27;A&#x27;</span>&#125;)) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[object Object]&#x27;</span> == &#123;<span class="attr">A</span>: <span class="string">&#x27;A&#x27;</span>&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="物件與物件"><a href="#物件與物件" class="headerlink" title="物件與物件"></a>物件與物件</h3><p>物件與物件的比對是使用傳參考的方式進行比對，因為參考位置不同，所以結果也就不相同，相關觀念可參考 <a href="/DvB-WdoORpSBG5qxQkYxBQ">物件傳參考</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([] == []) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="Truthy-與-Falsy"><a href="#Truthy-與-Falsy" class="headerlink" title="Truthy 與 Falsy"></a>Truthy 與 Falsy</h2><div class="alert alert-info">
Truthy（真值）指的是布林值轉換後為真的值，反之則為 Falsy（假值）
</div>

<p>需要特別注意的是 <strong>假值</strong> 的部分：</p>
<ul>
<li>undefined、null 屬於 Falsy</li>
<li><code>&quot;&quot;</code> 屬於假值，但 <code>&quot; &quot;</code> 屬於真值</li>
<li>NaN 屬於假值，和任何東西比對（包含自己）都是 false</li>
<li>假值本身如果套用包裹物件後會轉為物件，並為真值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">undefined</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;true&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<p>關於真值假值的判斷可以參考 <a href="https://dorey.github.io/JavaScript-Equality-Table/">JS Comparison Table</a></p>
<p><img src="https://i.imgur.com/fGqDtAE.png"></p>
<br>

<h2 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子"></a>邏輯運算子</h2><p>邏輯運算子常被運用在布林值的轉換，<strong>當第一個數值轉換為 true</strong></p>
<ul>
<li><code>&amp;&amp;</code>：回傳 第 2 個值，否則回傳 第 1 個值</li>
<li><code>||</code>：回傳 第 1 個值，否則回傳 第 2 個值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;		<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">456</span>;		<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">NaN</span>;		<span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">undefined</span>;	<span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="string">&quot;&quot;</span>;			<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a &amp;&amp; b ) <span class="comment">// true(2) =&gt; 456</span></span><br><span class="line"><span class="built_in">console</span>.log( a || b ) <span class="comment">// true(1) =&gt; &#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( c &amp;&amp; d ) <span class="comment">// false(1) =&gt; NaN</span></span><br><span class="line"><span class="built_in">console</span>.log( c || d ) <span class="comment">// false(2) =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( e &amp;&amp; a ) <span class="comment">// false(1) =&gt; &quot;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( e || a ) <span class="comment">// false(2) =&gt; &#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( e &amp;&amp; b ) <span class="comment">// false(1) =&gt; &quot;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( e || b ) <span class="comment">// false(2) =&gt; 456</span></span><br></pre></td></tr></table></figure>

<h3 id="例-1"><a href="#例-1" class="headerlink" title="例(1)"></a>例(1)</h3><p>而因為 &amp;&amp; 優先序高於 ||，所以會先比對完 &amp;&amp; 後，再由左至右比對，因此下列範例的流程會是</p>
<ol>
<li><code>c &amp;&amp; c</code> =&gt; 0</li>
<li><code>c || 0</code> =&gt; 0</li>
<li><code>0 || a</code> =&gt; 1</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log( c || c &amp;&amp; c || a ) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="例-2"><a href="#例-2" class="headerlink" title="例(2)"></a>例(2)</h3><ol>
<li><code>a &amp;&amp; b</code> =&gt; b</li>
<li><code>c &amp;&amp; a</code> =&gt; c</li>
<li><code>b || c</code> =&gt; b</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a &amp;&amp; b || c &amp;&amp; a ) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="例-3"><a href="#例-3" class="headerlink" title="例(3)"></a>例(3)</h3><ol>
<li>1000 &lt; 10000 =&gt; true</li>
<li>true 轉型後是 1</li>
<li>1 &lt; 10 =&gt; true</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1000</span> &lt; <span class="number">10000</span> &lt; <span class="number">10</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://www.hexschool.com/courses/js-core.html">JavaScript 核心篇</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>遞迴</title>
    <url>/note/20210820/1496359078/</url>
    <content><![CDATA[<h2 id="遞迴"><a href="#遞迴" class="headerlink" title="遞迴"></a>遞迴</h2><p>函式呼叫函式自己的行為，稱為 <strong>遞迴</strong>、或是 <strong>遞歸</strong> 。</p>
<span id="more"></span>

<p>先來看一下在 <strong>MDN</strong> 上的說明：<br>函式呼叫函式自己的行為，稱為遞迴、或是遞歸。它主要用於解決含有子問題的問題。<br>遞迴函式會收到兩個輸入：結束遞迴的基本情況（base case）或是延續遞迴的遞迴情況（recursive case）。</p>
<p>也就是說，函式透過呼叫自己的行為，在有限的條件下，透過判斷 <code>if...else</code> 執行循環的運算或程式碼。</p>
<h3 id="改寫九九乘法表"><a href="#改寫九九乘法表" class="headerlink" title="改寫九九乘法表"></a>改寫九九乘法表</h3><p>通常要寫一個簡單的九九乘法表，最直覺的是會想到使用 <code>for</code> 迴圈，我們先來看一下原本的寫法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> x <span class="subst">$&#123;k&#125;</span> = <span class="subst">$&#123;i * k&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是這樣就會變成雙層 <code>for</code> 迴圈，看起來相當冗長，萬一要再多加一層變成 <code>1 x 2 x 3 = 6</code>，這樣就會需要再多加一層，無論是在撰寫或是閱讀上都顯得複雜。</p>
<p>接下來看一下改成遞迴的寫法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print99</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span> x <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a * b&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span> (b &lt; <span class="number">9</span>) <span class="keyword">return</span> print99(a, b + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">9</span>) <span class="keyword">return</span> print99(a + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">print99(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果要再多加一層也是沒問題的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print99</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span> x <span class="subst">$&#123;b&#125;</span> x <span class="subst">$&#123;c&#125;</span> = <span class="subst">$&#123;a * b * c&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">if</span> (c &lt; <span class="number">9</span>) <span class="keyword">return</span> print99(a, b, c + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b &lt; <span class="number">9</span>) <span class="keyword">return</span> print99(a, b + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">9</span>) <span class="keyword">return</span> print99(a + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">print99(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 x 2 x 3 = 6</span></span><br><span class="line"><span class="comment">// 1 x 2 x 4 = 8</span></span><br><span class="line"><span class="comment">// 1 x 2 x 5 = 10</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="陣列遞迴展開"><a href="#陣列遞迴展開" class="headerlink" title="陣列遞迴展開"></a>陣列遞迴展開</h3><p>再來看一個經點案例，試著使用遞迴來展開多層陣列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arry = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]];</span><br><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatArray</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">  ary.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      flatArray(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatArray(arry));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>筆記</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>閉包 Closure</title>
    <url>/jscore/20210411/1553745186/</url>
    <content><![CDATA[<p>讓函式擁有自己的變數，使執行環境不會互相干擾。</p>
<hr>
<p>我們都知道閉包，但什麼是必包？主要功能是什麼呢？<br>先從字面上拆解，Closure 可以拆成 <code>Close</code> 和 <code>-ure</code> 字尾，<code>-ure</code> 接在動作的字根後面，表示動作本身、動作造成的結果、或是執行動作的人事物。<br>所以閉包本身就是一個關閉的動作，把程式碼片段關閉在一個函式內，限制作用域，建立自己的環境與外界隔絕。</p>
<span id="more"></span>

<h2 id="限制作用域"><a href="#限制作用域" class="headerlink" title="限制作用域"></a>限制作用域</h2><p>用一個錢包範例先來比較一下差異：<br>假設每個錢包都有1000元，大明花了300元，小明花了500元，計算每個人錢包裡的餘額</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wallet</span> (<span class="params">cost</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> balance = balance - cost</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> MING = wallet(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">var</span> ming = wallet(<span class="number">500</span>)</span><br><span class="line"><span class="built_in">console</span>.log(MING, ming) <span class="comment">// 700 200</span></span><br></pre></td></tr></table></figure>
<p>快速計算一下，大明錢包裡應該要有700元，小明應該還剩500元，但是結果小明卻是剩下200元，難道大明偷拿小明錢包裡的錢嗎？<br>一切都是誤會呀！因為現在沒有限制作用域，目前還是兩個人共用同一個錢包的狀態，如果想要讓他們他們各自花各自的錢，就要給他們一人一個錢包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balanceA = <span class="number">1000</span></span><br><span class="line"><span class="keyword">var</span> balanceB = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walletA</span> (<span class="params">cost</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> balanceA = balanceA - cost</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walletB</span> (<span class="params">cost</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> balanceB = balanceB - cost</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> MING = walletA(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">var</span> ming = walletB(<span class="number">500</span>)</span><br><span class="line"><span class="built_in">console</span>.log(MING, ming) <span class="comment">// 700 500</span></span><br></pre></td></tr></table></figure>

<h2 id="函式工廠"><a href="#函式工廠" class="headerlink" title="函式工廠"></a>函式工廠</h2><p>如果今天想要再計算別的錢包，就要再重複寫一次，這樣就會變成一樣的事情重複寫，不但看起來很複雜，也很沒有效率。這個時候就可以加入閉包限制作用域，建立一個「<strong>函式工廠</strong>」。<br><strong>讓每個功能相同的 function，對應到每個獨立的環境變數，且互不相干擾。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wallet</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> balance = <span class="number">1000</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    balance = balance - cost</span><br><span class="line">    <span class="built_in">console</span>.log(balance)</span><br><span class="line">  &#125;</span><br><span class="line">  counter()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userA = wallet(<span class="number">300</span>) <span class="comment">// 700</span></span><br><span class="line"><span class="keyword">var</span> userB = wallet(<span class="number">500</span>) <span class="comment">// 500</span></span><br><span class="line"><span class="keyword">var</span> userC = wallet(<span class="number">200</span>) <span class="comment">// 800</span></span><br></pre></td></tr></table></figure>
<p>這時候就可以讓每個人都可以獨立計算錢包餘額，也可以加入變數，一開始分別放入不同金額，管理各自的錢包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wallet</span>(<span class="params">initBalance, cost</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> balance = initBalance</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    balance = balance - cost</span><br><span class="line">    <span class="built_in">console</span>.log(balance)</span><br><span class="line">  &#125;</span><br><span class="line">  counter()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> userA = wallet(<span class="number">1000</span>, <span class="number">300</span>) <span class="comment">// 700</span></span><br><span class="line"><span class="keyword">var</span> userB = wallet(<span class="number">2000</span>, <span class="number">500</span>) <span class="comment">// 1500</span></span><br><span class="line"><span class="keyword">var</span> userC = wallet(<span class="number">1500</span>, <span class="number">200</span>) <span class="comment">// 1300</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10193009">重新認識 JavaScript: Day 19 閉包 Closure</a></li>
<li><a href="https://yixuntseng-bruce.medium.com/%E4%BA%94%E5%88%86%E9%90%98%E5%AD%B8%E5%89%8D%E7%AB%AF-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bjavascript%E7%9A%84%E9%96%89%E5%8C%85closure-c54321434e9f">快速上手JavaScript的閉包Closure</a></li>
</ul>
]]></content>
      <categories>
        <category>JS核心五分鐘</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>關注點分離：Todolist</title>
    <url>/demo/20210415/642765602/</url>
    <content><![CDATA[<h2 id="關注點分離"><a href="#關注點分離" class="headerlink" title="關注點分離"></a>關注點分離</h2><p>關注點分離（Separation of Concerns，SoC）就是將程式碼依照各種「目的」、「功能」進行分類和整理，讓每個區塊專注於各自負責的工作，彼此分工合作。<br>這麼做的優點是可以將程式碼進行切割，依照需求各自獨立處理，並讓程式碼單純化。<br>為了更清楚理解關注點分離應用，來實作一個簡單的 Todolist。</p>
<span id="more"></span>

<hr>
<h2 id="實作-Todolist"><a href="#實作-Todolist" class="headerlink" title="實作 Todolist"></a>實作 Todolist</h2><p>① 首先可以先規劃可能需要用到的功能，並用物件的方式宣告</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    data: [],           <span class="comment">// 儲存資料</span></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;&#125;,        <span class="comment">// 渲染畫面</span></span><br><span class="line">    <span class="function"><span class="title">addData</span>(<span class="params"></span>)</span> &#123;&#125;,       <span class="comment">// 加入資料</span></span><br><span class="line">    <span class="function"><span class="title">removeData</span>(<span class="params"></span>)</span> &#123;&#125;,    <span class="comment">// 刪除單筆資料</span></span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;&#125;           <span class="comment">// 執行</span></span><br><span class="line">&#125;</span><br><span class="line">component.init()</span><br></pre></td></tr></table></figure>

<p>② 先放測試資料，將資料先渲染到畫面上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    data: [</span><br><span class="line">      <span class="string">&#x27;第一段文字&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;第二段文字&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.list-group&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> content = <span class="built_in">this</span>.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;list-group-item&quot;&gt;</span></span><br><span class="line"><span class="string">          <span class="subst">$&#123;item&#125;</span></span></span><br><span class="line"><span class="string">          &lt;button type=&quot;button&quot; data-index=&quot;<span class="subst">$&#123;i&#125;</span>&quot;</span></span><br><span class="line"><span class="string">          class=&quot;btn btn-info btn-sm ml-3&quot;&gt;刪除&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">      `</span>).join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      list.innerHTML = content</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">component.init()</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/DCkpQbr.png?60" alt="Image"></p>
<p class="desc">確認一下畫面有正確渲染出來</p>

<p>③ 接著輸入單筆資料</p>
<ul>
<li>點擊「送出」按鈕時取得輸入框的值</li>
<li>新增到 <code>data</code> 陣列中</li>
<li>重新渲染畫面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    data: [</span><br><span class="line">      ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">addData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.input-group input&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> addBtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.input-group button&#x27;</span>)</span><br><span class="line">      addBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newText = text.value</span><br><span class="line">        text.value = <span class="string">&#x27;&#x27;</span> <span class="comment">// 清空輸入框</span></span><br><span class="line">        <span class="built_in">this</span>.data.push(newText)</span><br><span class="line">        <span class="built_in">this</span>.render() <span class="comment">// 重新渲染畫面</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.render()</span><br><span class="line">      <span class="built_in">this</span>.addData() <span class="comment">// 先註冊並等待點擊後執行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">component.init()</span><br></pre></td></tr></table></figure>

<p>④ 最後加上刪除資料<br>因為刪除按鈕會在渲染後才會印在畫面上，所以按鈕的宣告和執行都要寫在渲染後，不然會出現 <code>not defined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> component = &#123;</span><br><span class="line">    data: [</span><br><span class="line">      ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 刪除執行要寫在渲染後</span></span><br><span class="line">      <span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.list-group button&#x27;</span>)</span><br><span class="line">      btns.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> id = e.target.dataset.index</span><br><span class="line">          <span class="built_in">this</span>.removeData(id)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">addData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">removeData</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data.splice(id, <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">this</span>.render()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.render()</span><br><span class="line">      <span class="built_in">this</span>.addData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">component.init()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><iframe height="400" style="width: 100%;" scrolling="no" title="關注點分離：Todolist" src="https://codepen.io/ericadu/embed/XWpqwQr?height=400&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/ericadu/pen/XWpqwQr'>關注點分離：Todolist</a> by Erica
  (<a href='https://codepen.io/ericadu'>@ericadu</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>]]></content>
      <categories>
        <category>實作</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Todolist</tag>
      </tags>
  </entry>
</search>
